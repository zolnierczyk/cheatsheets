%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% writeLaTeX Example: A quick guide to LaTeX
%
% Source: Dave Richeson (divisbyzero.com), Dickinson College
% 
% A one-size-fits-all LaTeX cheat sheet. Kept to two pages, so it 
% can be printed (double-sided) on one piece of paper
% 
% Feel free to distribute this example, but please keep the referral
% to divisbyzero.com
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[10pt,landscape]{article}
\usepackage{amssymb,amsmath,amsthm,amsfonts}
\usepackage{multicol,multirow}
\usepackage{calc}
\usepackage{ifthen}
\usepackage[landscape]{geometry}
\usepackage[colorlinks=true,citecolor=blue,linkcolor=blue]{hyperref}
\usepackage[landscape]{geometry}
\usepackage{pdfpages}



\ifthenelse{\lengthtest { \paperwidth = 11in}}
    { \geometry{top=.5in,left=.5in,right=.5in,bottom=.5in} }
	{\ifthenelse{ \lengthtest{ \paperwidth = 297mm}}
		{\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
		{\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
	}
\pagestyle{empty}
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}
\makeatother
\setcounter{secnumdepth}{0}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}
% -----------------------------------------------------------------------

\title{Design Patterns}

\begin{document}

\raggedright
\footnotesize

\begin{center}
     \Large{\textbf{Design patterns ZOO}} \\
\end{center}
\begin{multicols}{3}
\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}

\section{Design philosophy}

\subsection{SOLID}
Acronym from:
\begin{itemize}
\item \textbf{S}ingle responsibility principle - A class should only have a single responsibility, that is, only changes to one part of the software's specification should be able to affect the specification of the class.
\item \textbf{O}pen closed principle - "Software entities ... should be open for extension, but closed for modification."
\item \textbf{L}iskov substitution principle - "Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program." also design-by-contract
\item \textbf{I}nterface segregation principle - "Many client-specific interfaces are better than one general-purpose interface."
\item \textbf{D}ependency inversion principle - One should "depend upon abstractions, [not] concretions."
\end{itemize}
\subsection{GRASP}
Acronym from \textit{General Responsibility Assignment Software Patterns}. Main thougts:
\begin{itemize}
\item Controller - The controller should delegate the work that needs to be done to other objects; it coordinates or controls the activity. It should not do much work itself. The GRASP Controller can be thought of as being a part of the application/service layer[3] (assuming that the application has made an explicit distinction between the application/service layer and the domain layer) in an object-oriented system with common layers in an information system logical architecture. 
\item Creator - Which class is responsible for creating objects is a fundamental property of the relationship between objects of particular classes. 
\item Indirection - The indirection pattern supports low coupling and reuse potential between two elements by assigning the responsibility of mediation between them to an intermediate object
\item Information expert - Using the principle of information expert, a general approach to assigning responsibilities is to look at a given responsibility, determine the information needed to fulfill it, and then determine where that information is stored. 
\item High cohesion - like single class responsibility. High cohesion means that the responsibilities of a given element are strongly related and highly focused
\item Low coupling - lower dependency between the classes to change in one class having lower impact on other classes 
\item Polymorphism - by definition responsibility for defining the variation of behaviors based on type is assigned to the type for which this variation happens
\item Protected variations - like open close principle
\item Pure fabrication - A pure fabrication is a class that does not represent a concept in the problem domain, specially made up to achieve low coupling, high cohesion, and the reuse potential thereof derived (when a solution presented by the information expert pattern does not). This kind of class is called a "service" in domain-driven design.

\end{itemize}

\subsection{YAGNI}
Acronym from  \textit{You aren't gonna need it} in another wards \textit{Always implement things when you actually need them, never when you just foresee that you need them.} or \textit{do the simplest thing that could possibly work}.

\subsection{KISS}
Acronym from \textit{Keep it simple stupid!}. Do not overthink or overengenier problem.

\subsection{Make right thing easy}
Make doing the right things easy and the wrong things hard. Peoples are not bad or good. In first place they are lazy.

\section{Why patterns?}
In software design many problems occurs agin and agin. Therefore we solve those problems already many times. Design patterns are simple essence of solution for some generalized problems.

\section{Clasification}

Main clasification of patterns is such:
\begin{itemize}
\item \textbf{Creational} - improve objects creation
\item \textbf{Structural} - improve objects structure
\item \textbf{Behavioral} - improve objects interaction
\item \textbf{Concurrency} - solve problem about multithreading
\item some other for microservices
\end{itemize}

\section{How to use them}
Design patterns never occur in code as pure as they are presented in book or in catalogue. This is our responsibility to modify patterns to mach our problem best. Also patterns do not occurs alone. In most cases we would like to use multiple patters at once mixed together to achieve our goals best. Also remember that there are lot of different implementation for single pattern and also they differ a lot between languages and technologies.

\section{Creational}

\subsection{Factory Method}
Separate creation of object from usage of objects. Factory will create object for user thanks that user don't need to known about real object type. This is fundamental method for dependency inversion / injection, low coupling, indirection and other.
\includegraphics[page = 1, width=\linewidth]{metauml/FactoryMethod2-1.pdf}

\subsection{Abstract Factory Method}
It is one level of abstraction higher than factory method. Here we have whole family of factories to make products.

\subsection{Builder}
It is like one level of abstraction higher than factories. Separate the construction of a complex object from its representation, allowing the same construction process to create various representations. 
\includegraphics[page = 1, width=\linewidth]{metauml/Builder2-1.pdf}

\subsection{Prototype}
Instead of creating object every time here we are cloning it from \textit{prototype}. Thanks that we can for example during lifetime of program creates multiple predefined prototypes to produce it in many copies.
\includegraphics[page = 1, width=\linewidth]{metauml/Prototype-1.pdf}

\subsection{Singleton}
Considered as anti-pattern. Allow only for one instance of class. We can generalize this pattern into Multition which is simple map of named objects one per name.
\includegraphics[page = 1, width=0.75\linewidth]{metauml/Singleton-1.pdf}

\section{Structural}

\subsection{Adapter}
Simple man in the middle which try to translate stuff between incompatible systems.
\includegraphics[page = 1, width=\linewidth]{metauml/Adapter1-1.pdf}

\subsection{Bridge}
Decouple an abstraction from its implementation allowing the two to vary independently. In other word abstract objects (in this meaning high level logic) instead of inheritance and polymorphism for delegation of work into derived classes contains/compose implementation objects.
\includegraphics[page = 1, width=\linewidth]{metauml/Bridge1-1.pdf}

\subsection{Composite}
Composite is a structural design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual objects.
\includegraphics[page = 1, width=\linewidth]{metauml/Composite-1.pdf}

\subsection{Decorator}
Decorator is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.
\includegraphics[page = 1, width=\linewidth]{metauml/Decorator-1.pdf}

\subsection{Facade}
Facade is a structural design pattern that provides a simplified interface to a library, a framework, or any other complex set of classes.

\subsection{Flyweight}
Flyweight is a structural design pattern that lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object.
\includegraphics[page = 1, width=0.65\linewidth]{metauml/Flyweight1-1.pdf}

\subsection{Proxy}
Proxy is a structural design pattern that lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.
\begin{itemize}
\item Virtual proxy - like lazy initialization
\item Protection proxy
\item Remote proxy
\item Logging proxy
\item Caching proxy
\item Smart proxy - like smart pointer
\end{itemize}
\includegraphics[page = 1, width=\linewidth]{metauml/Decorator-1.pdf}

\section{Behavioral}

\subsection{Chain of Responsibility}
Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.
\includegraphics[page = 1, width=\linewidth]{metauml/Chain1-1.pdf}

\subsection{Command}
Command is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request. This transformation lets you parameterize methods with different requests, delay or queue a request’s execution, and support undoable operations.
\includegraphics[page = 1, width=\linewidth]{metauml/Command1-1.pdf}

\subsection{Iterator}
Iterator is a behavioral design pattern that lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.).
\includegraphics[page = 1, width=0.65\linewidth]{metauml/Iterator1-1.pdf}

\subsection{Mediator}
Mediator is a behavioral design pattern that lets you reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object.
\includegraphics[page = 1, width=\linewidth]{metauml/Mediator1-1.pdf}

\subsection{Memento}
Memento is a behavioral design pattern that lets you save and restore the previous state of an object without revealing the details of its implementation.
\includegraphics[page = 1, width=\linewidth]{metauml/Memento-1.pdf}

\subsection{Observer}
Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.
\includegraphics[page = 1, width=\linewidth]{metauml/Observer-1.pdf}

\subsection{State}
State is a behavioral design pattern that lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.
\includegraphics[page = 1, width=\linewidth]{metauml/State1-1.pdf}

\subsection{Strategy}
Strategy is a behavioral design pattern that lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.
\includegraphics[page = 1, width=\linewidth]{metauml/Strategy1-1.pdf}

\subsection{Template Method}
Template Method is a behavioral design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.
\includegraphics[page = 1, width=0.85\linewidth]{metauml/TemplateMethod1-1.pdf}

\subsection{Visitor}
Visitor is a behavioral design pattern that lets you separate algorithms from the objects on which they operate.
\includegraphics[page = 1, width=\linewidth]{metauml/Visitor1-1.pdf}

\section{Concurrency}

\subsection{Active Object}
 Decouples method execution from method invocation that reside in their own thread of control. The goal is to introduce concurrency, by using asynchronous method invocation and a scheduler for handling requests. 

 \subsection{Balking}
Only execute an action on an object when the object is in a particular state. 

\subsection{Binding properties}
Combining multiple observers to force properties in different objects to be synchronized or coordinated in some way.

\subsection{Compute}
The same calculation many times in parallel, differing by integer parameters used with non-branching pointer math into shared arrays, such as GPU-optimized Matrix multiplication or Convolutional neural network. 

\subsection{Double-checked locking}
Reduce the overhead of acquiring a lock by first testing the locking criterion (the 'lock hint') in an unsafe manner; only if that succeeds does the actual locking logic proceed. 

\subsection{Event-based asynchronous}	
Addresses problems with the asynchronous pattern that occur in multithreaded programs.

\subsection{Guarded suspension}
Manages operations that require both a lock to be acquired and a precondition to be satisfied before the operation can be executed. 

\subsection{Join}
Join-pattern provides a way to write concurrent, parallel and distributed programs by message passing. Compared to the use of threads and locks, this is a high-level programming model. 

\subsection{Lock}
One thread puts a "lock" on a resource, preventing other threads from accessing or modifying it.

\subsection{Messaging design pattern (MDP)}
Allows the interchange of information (i.e. messages) between components and applications. 	

\subsection{Monitor}
An object whose methods are subject to mutual exclusion, thus preventing multiple objects from erroneously trying to use it at the same time. 

\subsection{Proactor}
Proactor is a software design pattern for event handling in which long running activities are running in an asynchronous part. A completion handler is called after the asynchronous part has terminated. The proactor pattern can be considered to be an asynchronous variant of the synchronous reactor pattern.[1] 

\subsection{Reactor}
A reactor object provides an asynchronous interface to resources that must be handled synchronously. 

\subsection{Read-write lock}
Allows concurrent read access to an object, but requires exclusive access for write operations. 

\subsection{Scheduler}
Explicitly control when threads may execute single-threaded code. 

\subsection{Thread pool}
A number of threads are created to perform a number of tasks, which are usually organized in a queue. Typically, there are many more tasks than threads. Can be considered a special case of the object pool pattern. 

\section{Sources}

\begin{itemize}
\item https://refactoring.guru/
\item https://github.com/ogheorghies/MetaUML
\item https://en.wikipedia.org/wiki/Software\_design\_pattern
\item and some books here will be added later
\end{itemize}

\end{multicols}

\end{document}